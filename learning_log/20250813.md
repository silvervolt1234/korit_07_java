## JS 에서의 객체 정의 방식
```jsx
const person1 = {
    name : "김일",
    age : 20
};
```
이상의 형태가 python 에서는 dictionary 라는 표현을 사용하고 java는 map 이라고 호칭


# 제네릭(Generic)
## 개념 및 정의
클래스나 메서드가 다룰 데이터 타입을 미리 명시해 재사용성과 유연성을 높이는 기술

### 타입 매개변수(Type Parameter)
- 클래스나 메서드에서 사용할 실제 타입을 '대신하여 사용하는 매개변수'
- 일반적으로 알파벳 대문자 하나로 표기
    1. T(Type) : 일반적으로 클래스 타입을 표기할때 사용
    2. E(Element) : 컬렉션의 요소를 나타낼 때 사용
    3. K(Key) : Map의 Key를 나타낼 때 사용
    4. V(Value) : Map의 Value 또는 제네릭을 나타낼 때 사용

### 재사용성
- 제네릭을 사용하면 다양한 자료형에 대해 하나의 클래스나 메서드를 정의 가능해 코드의 재사용을 높히고 중복 감소
```java
package org.example;

import lombok.Builder;
import lombok.Data;

@Builder
@Data
public class Person {
    String name;
    double height;
    double weight;
}

public void calcBmi(String name, double height, double weight) {
    double bmi = (weight / (height*height));

    if (bmi >= 30) {
        System.out.println(name + "님의 BMI 지수는 " + bmi + "으로 고도비만입니다.");
    } else if (bmi >= 25) {
        System.out.println(name + "님의 BMI 지수는 " + bmi + "으로 비만입니다.");
    } else if (bmi >= 23) {
        System.out.println(name + "님의 BMI 지수는 " + bmi + "으로 과체중입니다.");
    } else if (bmi >= 18.5) {
        System.out.println(name + "님의 BMI 지수는 " + bmi + "으로 정상입니다.");
    } else {
        System.out.println(name + "님의 BMI 지수는 " + bmi + "으로 저체중입니다.");
    }
}

// call1 형태로 메서드화
public void calcBmi1() {
    Scanner scanner = new Scanner(System.in);
    System.out.print("이름을 입력하세요 >>> ");
    String name = scanner.nextLine();
    System.out.print("키(cm)를 입력하세요 >>> ");
    double height = scanner.nextDouble() * 0.01;
    System.out.print("몸무게(kg)을 입력하세요 >>> ");
    double weight = scanner.nextDouble();

    calcBmi(name, height, weight);
}
```
와 같이 작성 가능. 그렇다면 Student 클래스가 Person 클래스를 상속받았다면
Student 클래스 용으로 method overloading을 해여하는가 고려하게 됨
그리고 Student의 상속을 받튼 추가 클래스가 생기면 더 복잡해짐
-> 실제론 UpCasting의 발생으로 문제 없음

### 타입 한정성(Type Safety)
- 컴파일 시점에 타입 체크를 할 수 있어 프로그램의 안정성을 높이고 명시적인 형변환을 감소



# Java 제네릭 와일드카드(Generic WildCard)

## 제네릭
- 클래스, 인터페이스, 메서드에 사용되는 자료형을 매개변수화 할 수 있도록 하는 문법으로 다양한 타입에 재사용이 가능

```java
public class Box<T> {
    // 필드 선언
    private T value;
    public void setValue(T value) {
        this.value = value;
    }
    public T getValue() {
        return value;
    }
}
```

과 같은 방식으로 작성했을 때 value의 자료형을 고정시키지 않고 사용이 가능
value에 String / Integer / Double / Product / Item ... etc 등으로 사용 가능
Java 자체의 자료형(class) 뿐만 아니라 개발자가 정의한 것도 넣을 수 있는 점에서 재사용성 높음

## 와일드 카드
- 이상의 제네릭 타입을 사용할 때 구체적 타입을 명싲하지 않고 범용적으로 처리할때 사용(? 기호 사용)

```java
import java.util.ArrayList;
import java.util.List;

public static void main(String[] args) {
    List<?> exampleList = new ArrayList<String>();
}
```
<?>은 어느 타입이든 가능하다는 의미

### 종류
1. 모든 타입 허용 
   - 읽기 전용. 어떤 타입이든 받아야만 할 떄
2. T 또는 T의 서브 타입(자식 클래스)
   - 읽기 전용. 제한된 타입에서 읽을 때
3. T 또는 T의 슈퍼 타입(부모 클래스)
   - 쓰지 전용. 제한된 타입으로 넣을 떄


ex) Animal문
```java
1. Animal(최상위)
public abstract class Animal {
    public abstract void move();
}

2. AnimalData

import lombok.AllArgsConstructor;
import lombok.Data;

@AllArgsConstructor
@Data
public class AnimalData<T> {
    private T animal;
    /*
        현재 AnimalData의 필드인 animal에 Animal 클래스의 상속을 받은
        Tiger / Human 객체를 필드에 대입

        그러나 T에는 어떤 클래스도 들어갈 수 있기 때문에 현재 상황에서는
        Car 클래스의 개겣도 animal 필드에 들어갈 수 있음

        이번 목표는 특정 클래스라면(=Animal 클래스의 상속을 받은 서브 클래스)
        해당 클래으세 맞는 객체 정보 출력
     */

    public void showData() {
        ((Animal) animal).move();       // 앞부분의 Animal은 형변호나 부분 / animal은 필드 이름
        // AnimalData의 필드인 animal을 Animal 타입으로 형변환해서 .move() 메서드를 호출
        // 여기서는 무조건 호랑이가 네 발로 뜁니다. / 사람이 두 발로 뜁니다 가 출력

        if(animal.getClass() == Human.class) {
            ((Human)animal).read();     // 현재 필드에 들어간 animal 객체의 클래스를 확인해
            // (.getClass()를 통해서) 그것이 Human 클래스라면
            // Human 클래스의 고유 메서드인 .read() 호출
        } else if (animal.getClass() == Tiger.class) {
            ((Tiger)animal).hunt();
        }
    }
}


4. Human

public class Human extends Animal{
    @Override
    public void move() {
        System.out.println("사람이 두 발로 뜁니다.");
    }

    public void read() {
        System.out.println("사림이 책을 읽습니다.");
    }
}

5. Tiger

public class Tiger extends Animal{
    @Override
    public void move() {
        System.out.println("호랑이가 네 발로 뜁니다.");
    }

    // 고유 메서드
    public void hunt() {
        System.out.println("호랑이가 사냥을 합니다.");
    }
}



6. Car

public class Car {
    public void move() {
        System.out.println("차가 움직입니다.");
    }

    public void brake() {
        System.out.println("차가 멈춥니다.");
    }
}

7. Main

public class Main {
    // 메서드 정의 영역
    // 현재 AnimalData 에서는 필드로 들어온 객체가 Animal의 서브 클래스인지 아닌지를 구분 못해
    // 이를 판단하는 메서드를 Main에 정의
    public AnimalData<? extends Animal> getAnimal(int flag) {
        if(flag == 1) {
            AnimalData<Human> animalData = new AnimalData<>(new Human());
            return animalData;
        } else if (flag == 2) {
            AnimalData<Tiger> animalData = new AnimalData<>(new Tiger());
            return animalData;
        }
        return null;
    }



    public static void main(String[] args) {
        AnimalData<Tiger> animalData1 = new AnimalData<>(new Tiger());
        AnimalData<Human> animalData2 = new AnimalData<>(new Human());
        AnimalData<Car> animalData3 = new AnimalData<>(new Car());
        /*
            현재 상황에서는 AnimalData에 Car 객체가 들어갔지만 오류 발생 않음
            Generic 개념으로 T에넌 어떤 클래스도 삽입 가능
         */
        animalData1.showData();
        animalData2.showData();
        // animalData3.showData();  오류 발생
        /*
            animalData3.showData()에서 오류가 발생
            AnimalData 클래스의 메서드 로직을 보면 
            필드를 (Animal)로 형변황시키는데 Car 클래스의 인스턴스를 Animal로 형변환이 불가능하기 때문
            
            즉 제네릭만을 사용하면 발생하는 문제점
         */

        //.getAnimal() 메서드 호출을 위한 객체 생성
        Main main = new Main();
        AnimalData<? extends Animal> animalData4 = main.getAnimal(1);
        AnimalData<? extends Animal> animalData5 = main.getAnimal(2);
        AnimalData<? extends Animal> animalData6 = main.getAnimal(3);
        
        /*
            .getAnimal()을 정의하지 않았다고 가정하면 현재 animal4,5,6의 필드에
            어떤 클래스가 들어갔는지 알 수 없음
            
            animalData6에는 null 값이 나오게 됨
         */
        if(animalData4 != null) {
            animalData4.showData();
        }
        if(animalData5 != null) {
            animalData5.showData();
        }
        if(animalData6 != null) {
            animalData6.showData();
        } else {        // animalData6 == null
            System.out.println("아무것도 없습니다.");
        }
    }
}
```

# Collection
- 여러 객체를 모아놓은 것들 -> 배열과는 차이 존재
- Java 에서의 List는 Python 에서의 List와 차이 발생

# 종류
1. List : 순서가 있는 데이터의 집합으로 중복 요소 허락
   - ArrayList : 배열 기반의 리스트, 요소(element) 접근 속도 빠름
   - LinkedList : 연결 리스트, 삽입 / 삭제 속도 빠름
2. Set : 중복을 허락하지 않는(List 와의 차이 #1) 데이터들의 집합
   - HashSet : 해시 테이블 기반의 집합, element의 순서를 보장하지 않음(List 와의 차이 #2)
3. Map : Key / Value의 쌍으로 이루어진 데이터들의 집합
   - HashMap : 해시 테이블 기반의 맵, 키 순서를 보장 x
   - TreeMap : 이진 검색 트리 기반의 맵, 키가 정렬 상태로 유지

* Java 상에서의 키(Key)-값(Value) 쌍을 지칭하는 용어 : Entry
* Js 상에서 객체의 키-값 쌍을 지칭하는 용어 : Property
* 문제는 Python 에서의 한국어로 속성을 지칭하는 영문 용어 : Attributes - Java 상에서의 field

### List - Set 형변환
- List는 순서가 있고 중복 허용이지만 Set의 경우 순서는 없고 중복 허용하지 않기 때문에
  List -> Set / Set -> List 형변환이 중요
- ex1) List로 전체 설문을 받고 Set로 중복을 제거하여 후보군만 남기는 형태
- ex2) Set로 중복 제거 후 다시 List로 돌려 .get(인덱스 넘버)로 조회 가능
- Set는 집합 개념과 유사. 다만 집합은 숫자로만 이루어진 방면 Set는 다양한 자료형을 기준으로 생성 가능

tmi1) 특정 element(List 내의) 검색 -> contains() 메서드 사용 리스트명.contains(목적어)
tmi2) FIFO / .pop() -> 삭제 여부가 아니라 collection 에서 삭제하고 삭제된 element를 return

