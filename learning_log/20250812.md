# Static

## 정의
- 클래스 수준에서 변수를 정의하거나 메서드 선언 시 사용
- static 으로 선언된 변수나 메서드는 클래스의 인스턴스에 미포함(해당 클래스의 인스턴스가 전부 동일값)
- 클래스 자체에 소속
- 이는 인스턴스를 생성하지 않고 접근이 가능하다는 점에서 일반적인 필드, 메서드와 구분

## 특징
1. 공유 : 모든 인스턴스가 동일한 static 변수에 접근. 따라서 데이터를 공유하거나 상태 저장에 유용
2. 클래스 수준의 변수 및 메서드 : static 변수와 메서드는 클래스 로드 시 메모리에 할당(객체가 생성될 때 x)
```java

public class KoreaItStudent07 extends KoreaItStudent {
    
    // 필드 정의
    private Stirng name;
    private int age;
    private String address;
    private String introduction = "코리아 아이티 국비 과정 7월";
}

public class Main {
    public static void main(String[] args) {
        KoreaItStudent07 student1= new KoreaItStudent07("김일",20,"부산광역시");
    }
}
```
이상의 KoreaItStudent07 클래스의 인스턴스들은 전부 다 private static String '정적 변수'를 지니고 있어
어느 클래스의 인스턴스인지만 확인해도 세부 정보 확인 가능(ex. KoreaItStudent04의 객체는 4월이라는 정적 변수. 필드 정의 필요 X)

3. 인스턴스 필요 없음 : 객체를 생성하지 않고도 클래스명.필드 / 클래스명.메서드명() 형태로 직접 접근 가능(필드는 private 지정자가 아님)
4. 메모리 효율성 : static 변수는 프로그램이 종료될 떄까지 한 번만 메모리에 할당

# Singleton Patter(싱글톤 패턴)
## 정의
소프트웨어 디자인 패턴 중 하나로 어떤 클래스가 하나의 인스턴스만 갖도록 보장하고 그 인스턴스에 접근할 수 있는 전역적인 접근법을 제공하는 패턴
데이터베이스 연결과 같은 리소스는 프로그램 전체에서 하나의 인스턴스만 사용해야할 때가 많기에 싱글톤 패턴 사용

## 특징
1. 하나의 인스턴스만 존재 : 하나의 인스턴스만 생성되고 이 인스턴스는 프로그램이 실행되는 동안 유지
2. 전역 접근법 : 싱클톤 인스턴스는 정적(static) 메서드를 통해 어디서든 접근 가능
   -> 객체명.메서드명() x / 클래스명.메서드명();
3. 인스턴스의 생명 주기 관리 : 클래스 자체가 인스턴스 생성을 관리하므로 다른 객체들이 인스턴스 생성 / 폐기 불가

## 장점
1. 메모리 절약 : 불필요한 인스턴스 생성을 방지해 메모리 절약 가능(static 변수 / 메서드 장점과 동일)
2. 글로벌(전역적) 접근 : 전역적 접근이 가능해 메모리 관리가 용이 -> 다만 잦은 접근 자체는 단점
3. 일관성 유지 : 애플리케이션 전반에서 하나의 인스턴스만 사용해 상태 일관성을 유지

## 단점
1. 테스트 어려움 : 싱글톤 패턴은 전역적으로 사용되 단위 테스트가 어려움
2. 의존성 숨김 : 싱글톤 남용시 클래스 간의 의존성 추적 무리

ex) 삼성 공장 관리 프로그램

```java

1. Samsung

import lombok.Getter;

import javax.xml.stream.FactoryConfigurationError;

public class Samsung {
    // 정적 필드
    private static Samsung instance;
    // 일반 필드(멤버 변수라는 표현을 쓰기도 함)
    @Getter         // getCompany()만 만들기
    private String company;
    private int serialNumber;

    // private로 NoArgsConstructor 정의
    private Samsung() {
        company = getClass().getSimpleName();       // 결과값 : Samsung
        serialNumber = 20250000;                    // 객체 생성시에 필드값 초기화
    }

    public static Samsung getInstance() {
        if (instance == null) {
            instance = new Samsung();
        }
        return instance;
    }

    public String createSerialNumber(String model) {
        return model + "_" + serialNumber;      // 싱글톤을 작성됬으니 객체 하나만 생성
        // Main 단계에서 다수이 객체에서 createSerialNumber()를 호출해도 전혀 serialNumber가 중복되지 않는다
        // 그래서 정적 변수로 선언하고 다수의 삼성 객체를 만들어도 serialNumber 중복 문제 개수에 불문하고 없음
    }
}


2. SmartPhone

package ch18_static.singleton;

import lombok.AllArgsConstructor;
import lombok.ToString;

@AllArgsConstructor
@ToString
public class SmartPhone {
    // 필드 정의
    private String Company;
    private String model;
    public String serial;
}

3. Factory

import lombok.AllArgsConstructor;

@AllArgsConstructor
public class Factory {
    // 필드 정의
    private String factoryName;

    // 메서드 정의
    public SmartPhone producSmartPhone() {
        System.out.println(factoryName + "에 스마트폰을 생성합니다.");
        // 접근 지정자가 없기에 default. 그리고 { } 내에 있으니 지역변수
        String model = "갤럭시 S26";
        String serial = null;

        Samsung samsung = Samsung.getInstance();
        // Samsung 객체를 생성 -> 싱글톤 써서 동일 객체 계속 대입

        serial = samsung.createSerialNumber(model);
        // 지금 현재 리턴 타입이 SmartPhone. 그러면 SmartPhone 객체가 나와야 함
        // 스마트폰 객체를 쓰기 위해서는

        SmartPhone smartPhone = new SmartPhone(samsung.getCompany(), model, serial);
        return smartPhone;
    }
}


4. FactoryMain

public class FactoryMain {
    public static void main(String[] args) {
        Factory factory1 = new Factory("제 1공장");
        Factory factory2 = new Factory("제 2공장");
        Factory factory3 = new Factory("제 3공장");
        Factory factory4 = new Factory("제 4공장");

        SmartPhone smartPhone1 = factory1.producSmartPhone();
        System.out.println(smartPhone1);
        SmartPhone smartPhone2 = factory2.producSmartPhone();
        System.out.println(smartPhone2);
        SmartPhone smartPhone3 = factory3.producSmartPhone();
        System.out.println(smartPhone3);
        SmartPhone smartPhone4 = factory4.producSmartPhone();
        System.out.println(smartPhone4);
        SmartPhone smartPhone5 = factory1.producSmartPhone();
        System.out.println(smartPhone5);
    }
}
```
결과 :
제 1공장에 스마트폰을 생성합니다.
SmartPhone(Company=Samsung, model=갤럭시 S26, serial=갤럭시 S26_20250000)
제 2공장에 스마트폰을 생성합니다.
SmartPhone(Company=Samsung, model=갤럭시 S26, serial=갤럭시 S26_20250000)
제 3공장에 스마트폰을 생성합니다.
SmartPhone(Company=Samsung, model=갤럭시 S26, serial=갤럭시 S26_20250000)
제 4공장에 스마트폰을 생성합니다.
SmartPhone(Company=Samsung, model=갤럭시 S26, serial=갤럭시 S26_20250000)
제 1공장에 스마트폰을 생성합니다.
SmartPhone(Company=Samsung, model=갤럭시 S26, serial=갤럭시 S26_20250000)

->이상의 코드를 실행시켰을 떄 알 수 있는 점은 어느 공장 객체에서 메서드를 호출했든지 간에 상관없이 
  createSerialNumber() 메서드를 호출한 결과가 하나로 이루어진다(싱글톤으로 인해)
  그래서 다수의 공장 객체에서 각각 produceSmartPhone() 메서드를 호출해도 일원화된 시리얼 넘버 부여



# 빌더 패턴(Builder Pattern)
```java
@AllArgsConstructor
public class Student {
    private int code;
    private String name;
    private String gender;
    private String school;
    private int semester;
    private Stirng[] subjects;
    private double[] scores;
}

public class StudentMain {
    Student student1 = new Student(내부에 이상의 필드 전부 입력, 그런데, 순서대로);
}
```

# 빌더 패턴이 생긴 이유
1. 복잡한 생성자 문제
   - 객체의 필드가 많아질수록 생성자 파라미터 수도 증가
     - 위의 예시에서는 AllArgs만 정의했지만 매개변수 생성자가 종류별로 필요
     - 롬복을 도입해도 필수적인것은 final 이기에 @NonNull 추가 지정 필요
2. 생성자 오버로딩 문제
   - 생성자에 필요한 조합이 다를 경우 수 많은 생성자를 일일히 정의 요구됨
   - 유지보수에 악영향 / 필드 하나 추가하면 생성자 전체 수정
     - RemoteController 작성 시 Volume 추가 했을때 main 단계의
       생성자에 필드 추가하고 생성자를 지웠다가 alt+ins 후 재생성 과정이 필요됨
3. 가독성과 유지 보수 문제
   - 코드를 작성하고 읽는 입장에서는 객체를 생성시 어떤 값이 어느 필드에 해당하는지
     명확하지 않아 실수 유발
```java
public static void main(String[] args) {
    Student student1 = new Student("김일", "김이");
    // 라고 했을 때 김일초등학교의 김이 학생인지 김일 학생이 김이 초등학교인지 구분이 어렵다는 문제 발생
}
```

## 정의
객체의 생성 과정에서 복잡한 생성자를 대신해 객체를 단계적으로 생성할 수 있도록 도와주는 디자인 패턴 중 생성 관련 파트
GoF(Gang of Four) 디자인 패턴 중 하나로 객채 생성시 가독성과 유연성 제공이 목표
    - 여기서 유연성 의미는 필드를 순서대로 채워넣지 않고 순서를 바꾸더라도 제대로 필드에 들어가는걸 의미

```java
public class Student {
    private String name;
    private String school;
    
    public Student(String name, string school) {
        this.name = name;
        this.school = school;
    }

    public Student(String name, string school) {
        this.name = name;
        this.school = school;
    }
}
```

## 특징 
1. 객체를 생성하는 여러 개의 필드를 명시적 관리 가능
2. 불필요한 생성자 오버로딩을 줄여 가독성 향상
3. 체이닝 메서드 를 사용해 객체를 직관적 생성
   - chaining method - 객체명.getClass().getSimpleName;

ex) Builder 예시문
```java

1. Person

import lombok.ToString;

@ToString
public class Person {
    private String name;
    private int age;
    private String address;

    // 생성자를 정의하는 법은 많은데 Lombok을 도입할수도 있지만
    // 그중에서도 몇 번쨰 argument로 이름은 넣는지 나이를 넣는지는 구분 힘듬

    private Person(Builder builder) {
        this.name = builder.name;
        this.age = builder.age;
        this.address = builder.address;
    }
    /*
        PersonMain 에서 생성자 호출을 통해서 객체를 생성하는 것을 막음
        그리고 매개변수에서 Builder builder 라고 되어 있고
        그 다음 줄 builder.name을 보면 builder 객체의 필드로 name / age / address 가 있는걸로 추정
        중요한 점은 Person의 필드와 Build의 필드가 동일해야 함
     */

    public static class Builder {
        private String name;
        private int age;
        private String address;

        /*
            이하의 코드는 method 정의 영역
            대부분의 경우 method는 행위를 나타내기 때문에 동사로 시작하지만
            Builder의 경우 대입될 필드와 동일한 메서드 명 필요(필드명=명사=메서드)
         */
        public Builder name(String name) {
            this.name = name;       // 객체가 생성되면 객체 이름으로 치환되는 키워드
            return this;            // 여태까진 name에 값이 없다가 36번 라인에 name field에 값이 대입된 객체 리턴
        }

        public Builder age(int age) {
            this.age = age;
            return this;
        }

        public Builder address(String address) {
            this.address = address;
            return this;
        }

        // 이 위쪽 코드까지는 field 명과 동일한 메서드 정의
        // 그 효과는 메서드명과 동일한 field에 값이 대입된 Builder 객체가 리턴

        public Person build() {
            return new Person(this);        // 이 this는 Builder 클래스의 인스턴스에 해당
        }
    }
}
        
        

2. PersonMain

public class PersonMain {
    public static void main(String[] args) {
        // 기존 객체 생성 방식
        // Person person1 = new Person();        // builder 생성시 private로 생성해서 불가능
        // 그리고 여태까지의 방식으로 서문성, 22, 부산광역시 금정구 라는 필드 값을 지니는 객체를 생성하면
        // Person person1 = new Person("서문성", 22, "부산광역시 금정구");
        // 를 빌더 패턴을 적용하면
        // 이하의 예시는 AllArgsConstructor
        Person person1 = new Person.Builder().name("서문성").age(22).address("부산광역시 금정구").build();
        System.out.println(person1);

        Person person2 = new Person.Builder().build();
        System.out.println(person2);

        Person person3 = new Person.Builder().address("서울특별시 종로구").build();
        System.out.println(person3);
    }
}

결과값:
Person(name=서문성, age=22, address=부산광역시 금정구)
Person(name=null, age=0, address=null)
Person(name=null, age=0, address=서울특별시 종로구)
```