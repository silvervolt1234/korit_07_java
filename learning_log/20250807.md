# 추상 클래스(Abstract Class)
- abstract - 추상적인

## 추상 클래스의 정의
1. 추상 메서드가 하나라도 포함되면 해당 클래스는 추상 클래스로 정의
2. 추상 클래스는 객체를 생성 불가능 -> 일반 클래스와의 차이
3. 다른 특징은 일반 클래스와 동일
4. 상속을 전제로 하는 클래스

- 추상 메서드(abstract method) - 선언만 있고 구현은 없는 메서드
- 추상 클래스(abstract class) - 추상 메서드가 하나 이상인 클래스

- 일반 메서드 vs. 추상 메서드 구조 차이({} 영영의 유무)

```java
// 일반 메서드
public void showInfo() {
    System.out.println("제 이름은 " + name + "입니다.");
}
// 추상 메서드
public abstract showName();
```

팝업 뜨는 것을 확인했을 때 메서드 본문(method body)에 해당하는 부분이 타이핑 했던 구현부를 의미
코드로는 {} 증괄호 영역에 해당

abstract 접근 지정자와 리턴 타입 사이에 명시되면 클래스도 동일하게 abstract 키워드 적용

이유 : 추상 메서드가 하나라도 있으면 추상 클래스로 정의 필요


## 추상 클래스의 장점
코드의 재사용성으 높이고 설계를 보다 명확히 할 수 있게 보조

## 추상 클래스의 목적
1. 공통된 기능 제공 : 여러 클래스에서 공통 사용 기능을 추상 클래스에서 정의 가능
2. 구체적인 구현 강제 : 추상 메서드를 통해 자식 클래스가 반드시 특정 메서드 구현 강제 가능
3. 코드의 재사용성 : 중복 코드를 줄이고 유지보수성 향상

## 주의사항
1. 객체 생성 불가능
2. 오버라이딩 개념은 재정의를 전제로 부모 클래스와 자식 클래스의 메서드가 다르게 굴러갈때만 이루어지면 되고
   부모 클래스의 메서드를 동일하게 사용할려면 받아올 필요 없이 일반적 사용 가능
   단, 자식 클래스 정의시 부모 클래스에 특정 메서드의 존재를 명확히 인식 필요



# 인터페이스(Interface)
- Java 에서 클래스가 구현해야하는 '메서드'들의 집합을 정의하는 규약
  (protocol)
- 인터페이스는 메서드의 시그니처(메서드명, 리턴 타입, 매개변수 목록)만을 포함하며
  메서드의 실제 구현은 미포함 -> 추상 메서드만 존재
- 다중 사옥을 지원 -> 이를 통해 클래스가 여러 인터페이스 구현
  - 추상 클래스는 단일 상속을 지원해서 상속과정을 알아보기 쉽고
  - 인터페이스는 다중 상속을 지원하기에 편리
## 특징
1. 추상 메서드 : 인터페이스 내의 모든 메서드들은 기본적으로 추상 메서드
   - 추상 클래스는 일반 메서드도 있었지만, 인터페이스는 강제적으로 추상 메서드
2. 상수 : 인터페이스 내에 선언된 변수는 모두 자동으로 public static final 상수로 취급
3. 다중 상속 : 클래스는 여러 인터페이스를 구현(implements) 가능

## 추상 클래스와의 공통점
- 모두 추상 메서드를 포함할 수 있고, 이를 서브 클래스에 구현

## 추상 클래스와 차이점
- 추상 클래스
  1. 부분 구현 허용 : 추상 클래스는 추상 메서드 뿐만 아니라 일반 메서드도 포함
  2. 상태 저장 가능 : 추상 클래스는 field를 가지기 가능
  3. 단일 상속 : (일반) 클래스는 하나의 추상 클래스만 상속 가능
  4. 생성자 : 추상 클래스는 생성자를 가질 수 있음
  
    ```java
    // 어떤 추상 클래스
    public abstract class Person {
        // 필드 선언
        String name;
        
        // AllArgsConstructor
        public Person(String name) {
            this.name;
        }
        
        // method 구현
        public abstract intrdouce();
    }
    
    // 위의 추상 클래스를 상속 받는 일반 클래스
    public class Student extends Person {
        // 서브 클래스의 필드 선언
        private String school;
        // 추상 클래스가 AllArgsConstructor 생성자만 가지고 있가에
        // Student 클래스가 객체르 생성할 수 있는 경우의 수는 이러한 2가지
        public Student(String name) {
            super(name);
        }
        
        public Student(String name, String school) {
            super(name);
            this.school;
        }
    }
    
    ```
    이상의 코드라인으로 알 수 있는것은 객체 생성을 직접적으로 하지 못하는 추상 클래스의 생성자의 유무로 인해
    자식 클래스의 생성자 정의 방식(객체 생성 방식)을 통제 가능하다는 것
    
    그래서 특정 서브 클래스의 객체 생성 방식을 강제하고 싶을 때 사용하는 것이 추상 클래스의 생성자

  5. 다양한 접근 지정자(Access Modifier) : 추상 클래스의 메서드와 변수는 다양한 접근 지정자 보유


# 인터페이스
  1. 완전한 추상화 : 인터페이스는 기본적으로 모든 메서드가 추상 메서드(Java8 이후는 default / static 사용 가능)
  2. 인터페이스는 인스턴스 변수(필드 중 객체마다 값이 다른 변수를 의미)를 가질 수 없고 상수만 선언 가능(final 키워드)
  3. 다중 상속 : 클래스는 여러 인터페이스를 구현 불가능(상속과 용어 구분)
  4. 생성자 없음 : 인터페이스는 생성가 보유 불가능
     - 필드에서 객체마다 다른 값을 지닐 수 없고 상수만 선언 가능하기에 필드에서 값을 대입하는 생성자 자체 생성 불가
  5. 자동 public : 인터페이스의 메서드들은 자동으로 public 이고 메서드 선언에 접근지정자를 명심할 필요 없음

#### 인터페이스 예제: 리모컨 만들기
```java
// 기본 명령어
// 1. Press
public interface Press {
    String NAME = "button";
    void onPressed();
}
// 2. Up
public interface Up {
  String onUp();
}

// 3. Down
public interface Down {
  void onDown();
}

// 명령어 행동 설정

// 1. press에 대한 행동
public class PowerButton extends Button{
    private boolean status;
    @Override
    public void onPressed() {
        if (status) {
            status = false;
            System.out.println("전원을 끕니다.");
        } else {
            status = true;
            System.out.println("전원을 켭니다.");
        }
    }
}

// 2. down에 대한 행동
public abstract class Button implements Press, Up, Down{
    @Override
    public void onDown() {

    }       // 일반 메서드지만 본문에 아무것도 X

    @Override
    public abstract void onPressed();

    @Override
    public String onUp() {
        return "올립니다.";
    }
}

// 3. up에 대한 행동
public class ChannelUpButton extends Button{

    @Override
    public void onPressed() {
        System.out.println("채널을 한 칸 올립니다.");
    }

    @Override
    public String onUp() {
        return "채널을 계속 " + super.onUp();
    }
}

// 필드 행동 부여
public class TvRemoteController {
    // 필드 선언
    private PowerButton powerButton;        // 접근지정자 클래스명 객체명 -> 여태까지의 작성 방법과 다름
    private ChannelDownButton channelDownButton;
    private ChannelUpButton channelUpButton;

    public TvRemoteController(PowerButton powerButton,
                              ChannelDownButton channelDownButton,
                              ChannelUpButton channelUpButton) {
        this.powerButton = powerButton;
        this.channelDownButton = channelDownButton;
        this.channelUpButton = channelUpButton;
    }

    // 이상에서 선언한 필드(객체)의 메서드를 호출 방법
    public void onPressedPowerButton() {
        powerButton.onPressed();
    }

    public void onPressedChannelDownButton() {
        channelDownButton.onPressed();
    }

    public void onDownChannelDownButton() {
        channelDownButton.onDown();
    }

    public void onPressedChannelUpButton() {
        channelUpButton.onPressed();
    }
    
    public void onUpChannelUpButton() {
        System.out.println(channelUpButton.onUp());
    }
}


// 실행
public class Main {
    public static void main(String[] args) {
        // 별개의 버튼 객체를 만듷지 않고 TvRemoteController 객체를 생성하는 방법
        TvRemoteController tvRemoteController = new TvRemoteController(
                new PowerButton(), new ChannelDownButton(), new ChannelUpButton()
        );

        tvRemoteController.onPressedPowerButton();
        tvRemoteController.onPressedChannelDownButton();
        tvRemoteController.onDownChannelDownButton();
        tvRemoteController.onPressedChannelUpButton();
        tvRemoteController.onUpChannelUpButton();
    }
}

```

#### 결과
전원을 켭니다.
채널을 한 칸 내립니다.
채널을 계속 내립니다.
채널을 한 칸 올립니다.
채널을 계속 올립니다.
채널을 계속 올립니다.


tmi1) interface 이기 때문에 변수 앞에 접근 지정자를 명시하지 않고 final 키워드도 적지 않지만
      public final이 생략. 그래서 String 앞에 final을 명시해도 불필요하다는 알림 발생

tmi2) 불가능한 예시들
      - String age;      // field(인스턴스 변수) 선언 불가능
      - public Press(){};    // 생성자 불가능
      - void popOut() {
            System.out.println("추상 메서드 x / 일반 메서드 케이스"); 
         }

tmi3) 클래스는 단일 상속만 가능. 키워드는 -> extends
      인터페이스는 다중 상속이 가능. 키워드는 implements