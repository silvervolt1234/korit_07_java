# 참조 자료형 캐스팅(Reference Type Casting)
- 객체 지향 프로그래밍(OOP)에서 중요한 요소 중 하나
## 사전 지식
- Java 상에서 자료형은 크게 두가지로 구분
    1. 기본 자료형(Primitive Type) : int, double, char, float, long
    2. 참조 자료형(Reference Type) : 객체를 참조하는 변수로 클래스나 인터페이스로 생성된 객체
- 참조 자료형 캐스팅이란? - 객체의 자료형을 변호나하는 작업
- int -> double / int -> long 으로 변경하는 것은 형변환(conversion)
## 캐스팅 종류
1. UpCasting : 하위 클래스 타입의 객체를 상위 클래스로 변환
2. DownCasting : 상위 클래스 타입의 객체를 하위 클래스로 변환

## 미리 기억할 연산자(Operator) : instanceof
ex : 1 + 1 = 2 에서 +가 연산자 / = 대입 연산자인것처럼
ex : 객체명 instanceof 클래스명 -> return true / false

## UpCasting
- 암시적(Implicit)로 구성
  - 알아서 변환. 변환 시점은 인지해야함
### DownCasting
- 명시적(Explicit)으로 구성
  - 반드시 개발자가 적절한 장소와 시간대에 사용
## 업캐스팅과 다운캐스팅의 활용
- 캐스팅은 다형성 (Polymorphism)를 구현할 때 사용. 상위 클래스 타입으로
  객체를 처리하면서도 특정 상황에서는 하위 클래스의 고유 기능 사용 가능
## 장단점
- 장점 : 
  - 코드 유연성 : 업캐스팅을 통해 '다양한 객체를 하나의 상위 클래스 타입으로 관리' 가능
  - 다형성 구현 : 메서드 오버리이딩과 함꼐 사용하면 코드의 재사용성
- 단점 :
  - 다운캐스팅의 위험성 : 잘못 다운캐스팅 할 수 있음
    - 상위 클래스 A와 하위 클래스 B, C가 있다고 가정할 때, B의 객체인 b를 A로 업캐스팅하고
      C로 다운캐스팅하려고 시도하면 컴파일링 오류 발생
  - 복잡성 증가 : 코드 가독성이 떨어질 수 있음
    - 이리저리 바꾸기 때문으로 업스캐팅은 암시적으로 발생해서 어디서 이루어졌는지 확인 못하다가
      갑자기 명시적 다운캐스팅으로 코드 읽기 힘들어질 수 있음
  - 이상의 문제들을 해결하기 위한 연산자 -> instanceof
    코드 예시
```java
public static void main(String[] args) {
    System.out.println(objectA instanceof Class A); // 결과값 true / false
}
// object A : 검사하려는 객체명
// object B : 객첵 검사될 클래스 / 인터페이스
```
- return 값은 objectA가 ClassA의 인스턴스이거나 하위 클래스의 인스턴스인 경우 true 아니면 false
- 클래스A 객체명 = new 클래스B();를 통해 객체를 생성할 경우
  1. Override가 적용된 메서드 = 자식 클래스의 메서드 호출
  2. 클래스B(자식 클래스)의 고유 메서드는 호출 불가능
    - 재정의된 method 버전으로 호출이 된다면 애초에 클래스B 객체명 = new 클래스B();로 생성시
      재정의 method도 호출되고 고유 method도 호출 가능하다고 생각 가능하나 실제로는 불가능
-  다운캐스팅은 명시적으로 이루어짐
   방법:
   (클래스명)객체명; -> (int)2.3;과 같은 방식. conversion의 객체버전
   기본 자료형의 형뱐환을 벗어나 참조 자료형까지 고려
- 캐스팅별 사용 용도:
  - 업캐스팅 : 재정의 메서드 실행용
  - 다운캐스팅 : 고유 메서드 실행용

## 프로그램 구현 사항
```java
public interface Power {
    void on();
    void off();
}
```
라는 인터페이스가 존재할 때 interface Power를 implement한 다양한 클래스 정의
여기서 Computer / AirConditioner / Speaker 들이 전부 Power를 implement 하면 이사의 세 클래스들은 강제적으로
on() / off() 메서드들을 override 필요

그래서 Computer / AirConditioner / Speaker 객체들을
전부 Power로 업캐스팅한다면
Computer / AirConditioner / Speaker 객체의 원래 클래스와 상관없이
Power 클랫의 조작만으로 on() / off() 메서드 호출이 가능

즉 B b = new B();로 애초에 객체를 생성하면 안되냐는 건
A의 자식 클래스가 B 하나일 경우만 적용
A의 자식클래스가 B C D E F... 등 여러개일 경우
그것을 업캐스팅하면 A가 가지고 있는 부모 메서드를 호출해
다수의 서로 다른 클래스의 객체를 통제할 수 있다는 장점으로 업캐스팅 적용
그리고 다운캐스팅을 해 각각의 클래스에서 고유 메서드 실행 가능

tmi. Java의 index 넘버에는 음수값이 없어서(python은 존재) 실패 표현을 주로 -1로 표기
하지만 0에 가까운 수이기에 -100이나 return 값으로 나올 수 없을만한 음수값을 지정하기도 하는데
제일 보편적인 값이기에 인지 필요