# 배열(2)
```java
        for (int i = 0 ; i <scores.length ; i++) {
            if (scores[i] > 89) {
                a++;
            } else if (scores[i] > 79) {
                b++;
            } else if (scores[i] > 69) {
                c++;
            } else if (scores[i] > 59) {
                d++;
            } else {
                f++;
            }
        }
        System.out.println("A 학생 수 : " + a);
        System.out.println("B 학생 수 : " + b);
        System.out.println("C 학생 수 : " + c);
        System.out.println("D 학생 수 : " + d);
        System.out.println("F 학생 수 : " + f);
```
이제 고민할 부분 -> 변수 a b c d f가 하나하나 int 이기에
int[] 배열로 선언해 변수 개수 감소 가능
```java
int[] grade = {0, 0, 0, 0, 0};
```
// A에 해당하는 점수라면 grade[0] 숫자를 +1 해주고, B에 해당하면 grade[1] +1...
// 여러줄 사용 필요 x

## 향상된 for문
일반 for 문과의 차이점 :
일반 for 문의 경우 index 넘버(주소지)를 명확히 알기에
일일히 element의 숫자를 세는 것이 번거로워서
일종의 field 참조를 통해 int 추출로 대입

하지만 for (int i = 0; ...) 부분에서 int i는 for문 내부에서 선언되고 내부 사용만 가능

이를 응용해 배열 내의 element에 for문 내부에서만 사용하는 변수에 대입하는 방식으로
index 넘버(주소지)의 사용없이 적용할 수 있는 for 반복문이 있는데 이것이 향상된 for문

제약 :
읽기만 가능하고 쓰기 불가능

형식 :
```java
for(자료형 변수명 : 반복 가능 객체(배열)) {
    반복 실행문
    }
```

ex)
```java
int[] num = new int[200];

        // 1부터 200까지 대입

        // 일반 for 문 형태로 1 2 3 4...200까지 출력
        for (int i = 0 ; i < num.length ; i++) {
            num[i] = (i + 1);
            System.out.print(num[i] + " ");
        }
        System.out.println();
        // 향상된 for 문 출력
        for (int number : num) {
            System.out.print(number + " ");
            // 첫 번째 반복에서 num 의 첫 번재 element인 1을 number에 대입
            // 즉 number = 1; 이 된 상황 -> 36번 라인
            // 대입이 된 상태로 37번 라인 실행 -> 1 까지 출력
            // 다음 반복으로 넘어가 num 의 두 번째 element인 2를 number에 대입
            // 37번 실행 -> 다음 3 대입
            // 39번 대입.....200 대입
            // 39번 실행하고 마무리(마무리 시점은 마지막 element 대입 후, 반복 실행문 실행 후)
            // 이후 반복문 바깥에서는 int i 와 동일하게 number 변수 사용 불가
        }
        // number = 201;    // 에러
        System.out.println();
```

## 배열의 출력
배열의 출력
여태까진 정확히는 배열을 출력인 아닌 배열 내부의 element를 출력
System.out.print(arr01); 과 같은 출력문을 작성시 주소값만 나옴

그래서 element 값을 조정하거나 더하거나 같은 추가적 가공을 위해 for 반복문을 사용했는데
변형 없고 배열 자체를 확인하고 싶을때마다
main에 반복문 작성 혹은 method 정의 등 번거로운 일

Arrays 클래스를 사용하고 정적 메서드인 .toString(배열명)을 사용하면
배열 전체 출력 가능

여기서 클래스명.메서드명()에 주목
scanner.nextLine()과는 다르다
추후 toString()이라는 메서드 사용

중요한 점은 동일한 method 명이라고 해도 어떤 클래스에 종속되어있냐에 따라 다른 결과값

ex) 배열 전체 출력 예시
```java
 System.out.println(Arrays.toString(numbers));

        Method01.call1();
        System.out.println(Method01.call3());

        Integer[] nums = { 3, 6, 7, 1, 9, 2, 10, 5, 4, 8};
        System.out.println("정렬 전 배열 : " + Arrays.toString(nums));

        // 오름차순 정렬
        Arrays.sort(nums);      // 결과값이 void 이기에 원본 배열의 정렬
        System.out.println("오름차순 정렬 후 배열 : " + Arrays.toString(nums));
        // 내림차순 정렬
        // 마찬가지로 원본 배열을 전부 변환
        Arrays.sort(nums, Comparator.reverseOrder());
        System.out.println("내립차순 정렬 후 배열 : " + Arrays.toString(nums));
```
이상의 경우 sort() 메서드에 오름차순음 argument가 하나였지만 내림차순 할 경우 argument가 두개
이상의 과정이 overloading의 과정을 파악하는 과정
두 번째 argument로 Comparator.reverseOrder();가 사용되옸는데
Comparator.reverseOrder()의 결과값/return이
sort() 메서드의 두 번째 argument로 사용된 점에서 함수 프로그래밍의 일종
하지만Comparator.reverseOrder() 메서드를 쓰려면
기본 자료형(원시 자료형 / primitive type) int[] 배열을 사용할 수 없어서
Integer[] 배열을 사용했는데 현재는 char -> String 처럼 int -> Integer로 인식

## 다차원 배열(Multi-Dimensional Array) 중에서 2차원 배열

: 다차원 배열은 2차원 이상의 배열을 의미하지만 개발환경 상
2차원 시앙의 배열을 다우른 경우는 드물기에 2차원 기준

    형식 :
```java
    int[][] arr01 = new int[크기][크기];        - 선언 방식 # 1
    int[][] arr02 = new int[크기][];           - 선언 방식 # 2
    int[][] arr03 = {{1, 2}, {3, 4}, {5, 6}}     - 선언 방식 # 3
```
    

2차원 배열 선언 시, 열의 크기는 지정하지 않아도 되지만, 행의 크기는 할상 지정
-> 2번 방식
    1열 2열(column)
     ↓ ↓ 
    {1,2}, -> 1 행(row)      가로줄을 행
    {3,4}, -> 2 행
    {5,6}  -> 3 행


# cord convention 관련

```java
import java.util.Scanner;

publioc

class PersonMain {
    public static void main(String[] args) {
        // 사용할 외부 및 내부 클래스 목록들 전부 import
        Scanner scanner = new Scanner(System.in);
        Array08 array08 = new Array08();
        // 사용하는 변수 목록들 전부 선언
        int randomNum;
        double[] scores = new double[25];
        String[] students = new String[25];
        // ...
        // 이후 로직들이 밑에 길게 있다고 가정하다
        // 밑에서 갑자기 students가 있다고 가정
        if (randomNum < 0)
        {
            // 이런 형식으로 실행문을 쓰라고 회사에서 규정 있을수도 있음
        }
    }
}
```

# 상속(Inheritance)
- 객체지향프로그래밍(OOP)의 핵심 개념 중 하나로, 기존 클래스(부모(슈퍼) 클래스)의
  field와 method를 재사용하여 새로운 클래스(자식(서브) 클래스를 만드는 것을 의미)

## 상속의 필요성
- 상속을 통해 공통기능을 부모 클래스에 정의하고 이를 여러 자식 클래스가 재사용 가능
  - 동물(Animal) 클래스가 있고 이를 상속 받는 개(Dog) / 고양이(Cat) 클래스가 있다고
    가정했을 때, 동물의 공통적인 field(이름 / 나이 등)와 행위(걷기 / 먹기 등)을
    부모 클래스에 정의, 개와 고양이는 각각 고유한 특성(짖기 /  우다다다)을 추가 가능

- 이상의 과정을 거칠때 이점 : Dog에 이름 / 나이 / 걷기 / 먹기 / 짖기를 정의하고
  또 Cat에 이름 / 나이 / 걷기 / 먹기 / 우다다다 를 정의하는 등 공통된 부분을
  정의하는 일 없이 특정 field와 메서드만 정의 가능 -> 중복 코드 감소

## 상속의 특징
1. 단일 상속
  - Java는 단일 상속만 지원. 하나의 클래스는 한 번에 하나의 부모 클래스만 상속 받을 수 있어 구조가 간단하고 명확
2. super 키워드
  - 클래스의 생성자 및 setter 에서 학습한 this와 유사한 개념으로
    부모 클래스의 field에 접근하거나 부모 클래드의 생성자를 호출 시 사용(두 가지 사용법 존재)
3. method override
  - 자식 클래스에서 부모 클래스의 기본 동작을 `재정의` 가능. 이를 통해 자식 클래스는 부모
    클래스의 기본 동작을 자신만의 방식으로 변경 가능
  - 예시
    - Animal 클래스의 걷기를 Dog가 상속 받고 네 발로 걷기로 재정의. Human 클래스가 걷기를 상속받고 두발로 걷기로 재정의가 가능
4. final 키워드 - 클래스에 final이 붙으면 상속 불가
  - method에 final이 붙으면 메서드 오버라이딩 불가능

## 장점
1. 코드 재사용성 - 동이한 코드를 반복적으로 작성할 필요 x
2. 유지 보수의 용이성
   - 부모 클래스의 변경 사항이 자식 클래스에 자동 반영되어서 위계 파악 후 수정
3. 객체 간 관계 표현 - IS-A 관계가 명확
   - IS-A 
   '개'는 '동물'의 일종이다. 와 같은 예시로 IS-A는 is a kind of의 축약어
   - 그렇기에 미리 만든 Animal / Tiger / Human 클래스를 예로 들면
   - Human / Tiger는 Animal 클래스의 자식(서브) 클래스다.

## super 키워드
1. super();             -> 부모 생성자를 호출
2. super.메서드명();      -> 부모 클래스의 메서드 호출

부모-자식의 상속관계가 성립되어 있을 때
부모 클래스에서 기본 생성자 없이 매개변수 생성자만 있다면
자식 클래스에서 완벽한 기본 생성자를 생성 불가능

자식 클래스의 객체 생성시 필수적으로 부모 클래스의 생성자를 호출하기 때문

// 어떤 객체를 생성한다고 가정 시
A a = new B();
같은 형태의 객체 생성 방식이 튀어 나옴(이상 정보처리기사 단골 문제)

ex) 상속 예시(Animal / Tiger / Main)

#### Animal
```java
public class Animal {
    // 필드 정의
    private String animalName;
    private int animalAge;

    // 생성자 기본 생성자 하나 매개변수 생성자 하나짜리 두 개
    // AllArgs 하나 해서 네 개 생성

    public Animal() {
    }

    public Animal(String animalName) {
        this.animalName = animalName;
    }

    public Animal(int animalAge) {
        this.animalAge = animalAge;
    }

    public Animal(String animalName, int animalAge) {
        this.animalName = animalName;
        this.animalAge = animalAge;
    }
    
// Getter / Setter 생성

    public String getAnimalName() {
        return animalName;
    }

    public void setAnimalName(String animalName) {
        this.animalName = animalName;
    }

    public int getAnimalAge() {
        return animalAge;
    }

    public void setAnimalAge(int animalAge) {
        this.animalAge = animalAge;
    }

    public void move() {
        System.out.println("움직입니다.");
    }
}
```

#### Tiger
```java
public class Tiger extends Animal{ // 자식 클래스 extends 부모 클래스
    // field와 getter / setter는 없으나
    // Tiger의 고유 메서드는 따로 정의 가능

    // 고유메서드 #1
    public void hunt() {
        System.out.println(getAnimalName() + "이(가) 사냥을 합니다.");
    }

    // 고유메서드 #2
    public void hunt(String prey) {
        System.out.println(getAnimalName() + "이(가) " + prey + "를 사냥합니다.");
    }
    
    // 재정의된 methods : 부모 메서드의 결과값과 다르게 작성하면 전부 재정의에 해당
    @Override                           // 해당 메서드는 상속 받은 것
    public String getAnimalName() {
        return super.getAnimalName() + "님";
    }

    @Override
    public void setAnimalName(String animalName) {
        super.setAnimalName(animalName);
    }

    @Override
    public int getAnimalAge() {
        return super.getAnimalAge();
    }

    @Override
    public void setAnimalAge(int animalAge) {
        super.setAnimalAge(animalAge);
    }

    @Override   // 이 경우는 method 명만 동일하고 전부 다 재정의
    public void move() {
        System.out.println("호랑이가 네 발로 걷습니다.");
    }
}
```

#### Main
```java
package ch13_inheritance;

public class Main {
    public static void main(String[] args) {
        Animal animal1 =  new Animal();
        Animal animal2 =  new Animal("나비");
        Animal animal3 =  new Animal(1);
        Animal animal4 =  new Animal("바둑이", 2);

        System.out.println(animal1.getAnimalName());

        // Tiger 객체 생성
        Tiger tiger1 = new Tiger();
        tiger1.setAnimalName("푸바오");
        tiger1.setAnimalAge(3);
        String tigerName = tiger1.getAnimalName();
        int tigerAge = tiger1.getAnimalAge();
        System.out.println("이 호랑이의 이름은 " + tigerName +"입니다.");
        System.out.println(tigerAge + "살입니다.");

        tiger1.hunt();
        tiger1.hunt("물고기");
        tiger1.move();      // 재정의된 move() 호출
        animal1.move();     // 부모 method 원본 그대로 호출
        System.out.println();

    }
}
```

결과
이 호랑이의 이름은 푸바오님입니다.
3살입니다.
푸바오님이(가) 사냥을 합니다.
푸바오님이(가) 물고기를 사냥합니다.
호랑이가 네 발로 걷습니다.
움직입니다.