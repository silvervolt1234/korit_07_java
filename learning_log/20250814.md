### StrMap
- Map에 값을 저장할 때는 입력 순서대로 출력되지 않고 .get("키값로) 값을 조회
- 출력 형태 : {키1=value1, 키2=value2.....}
- 특정 키의 value 수정(put/value)
  - put : key 에는 value가 하나 뿐이기에 처음 값을 넣는것처럼 key를 새로 생성해 초기화
  - replace : 없는 값은 삽입 불가
- 특정 키의 존재 여부 -> containsKey
  - boolean searchKey = 예제1.containsKey("키1")
- 특정 키의 존재 여부 -> containsValue
  - boolean searchKey = 예제1.containsValue("value")
- Map을 Set 으로 저장 가능. 단 List 로는 직접 변경 불가
  - Set<Map.Entry<String, String>> entrySet1 = new HashSet
  - Set<Map.Entry<String, String>> entrySet2 = strMap1.entrySet();

# JSON

## 정의
JSON(JavaScript Objected Notation) - 본래 자바 스크립트 언어로부터 파생되어 자바 스크립트 구문을 따르는 언어 독립형 데이터 포맷

프로그래밍 언어나 플랫폼에 독립적이기에 구문 분석 및 JSON 데이터 생성을 위한 코드는 Java / Python 등 다양한 언어에서 사용 가능
```json
{
  "이름 공간(키)": "값",
  "값 구분자": "각각의 값들은 ',' (콤마)로 구분되어야 합니다.",
  "이스케이프": "키나 값에서 큰따옴표를 쓰고 싶으면-특정 문자를 이스케이프하려면- \"처럼 문자 앞에 역슬래시를 붙입니다.",
  "자료형": "표현 가능한 자료형은 문자열, 숫자, 불리언, 널, 객체, 배열 6개입니다.",
  "문자열값": "암울한 암흑에 휩싸인 머나먼 미래, 오직 전쟁만이 있을 뿐.",
  "숫자값": 19721121,
  "불리언값": true,
  "널값": null,
  "객체값(JavaScript식)": {
    "값 1": 3.14159265358979323846264338,
    "값 2": false,
    "값 3": {
      "객체 안에": "객체를 넣는 것도 가능하지요",
      "구분자": "또한 키와 값은 ':'로 구분됩니다"
    }
  },
  "배열값": [
    "이것은 배열입니다.",
    {
      "현재값의 인덱스": 1,
      "이런 식으로": "배열 안에 여러 값을 넣을 수 있습니다."
    },
    [ "배열", "안에", "배열을", "넣는 것도", "가능하지요" ]
  ],
  "값의 개수가 적을 때는": "다음과 같이 한 줄로도 객체와 배열 표현이 가능합니다.",
  "한 줄 객체": { "황제": "+몰라 레후+", "앙그론": "No, Stop!", "오메곤": "하지만 승리가..." ,  "가즈쿨": "Waaaagh!" },
  "한 줄 배열": [ "암울한", "암흑에", "휩싸인", "머나먼", "미래,", "오직", "전쟁만이", "있을", "뿐." ],
  "예시": "예시입니다."
}
```

### Json과 Map의 차이점
1. Map의 key는 " "가 없지만 JSON은 모든 key에 String 자료형처럼 보이게 " "가 존재
2. Map은 key1=value1의 형태로 작성되지만 JSON은 "key1":value1 형태로 작성

### Json의 특징
- 메서드는 argument로 Java Object 자체를 집어넣는게 가능하고 Map 으로 생성된 entry를 Json 형태로 바꾸는것도 가능
  toJson()은 overloading이 이루어진다

- gson에 toJson()이 있고 gsonBuilder도 toJson()이 존재

- json -> Map / Java Object로 바꾸기
형식 :
gson.fromJson(제이슨데이터, 바꾸려는_클래스.class)

```java
User user2 = gson.fromJson(jsonUser2, User.class);
System.out.println(user2);
Map<String, String> productMap2 = gson.fromJson(jsonProduct2, Map.class);
System.out.println(productMap2);
```

특정 Java 객체와 Json String data가 있다고 가정했을때 서로 고칠 수 있고 Map과 Json 데이터 역시 동일
gsonBuilder로 fromJson()을 적용해도 PrettyPrinting 적용 불가

결과값 : {username=kim1, password=9876, email=a@test.com, name=김일, age=20}

이상의 이유는 fromJson()이라는 메서드명에서 나오듯 JsonData(=String Data)를 Map로 바꾸는 것
String의 경우 개행을 통해 PrettyPrinting이 적용 가능하지만 Map은 toString() 메서드를 재정의하지 않으면 default 출력
그래서 콘솔 출력값은 동일

```java
Map<String, String> userMap1 = gson.fromJson(jsonUser2, Map.class);
Map<String, String> userMap2 = gsonBuilder.fromJson(jsonUser2, Map.class);
System.out.println(userMap1);
System.out.println(userMap2);
```
이상의 코드를 Java로 만든것을 Java -> Json -> Map의 과정으로 변경 가능
하지만 Map의 경우 Json 으로 바꾸는건 자유나 Java로 만들려고 하면 클래스 정의 필요

json -> jsonObject로 변환
json =/= jsonObject 라는 뜻