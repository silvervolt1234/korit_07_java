# Exception

## 예외와 오류

예외(Exception)란?
: 개발자가 예측할 수 있고 그에 대해 대비할 수 있는것들
오류(Error)란?
: 개발자가 예측할 수 있지만 해결할 수 없거니 / 예측 불가능한 것

다수의 예외들은 이미 개발자들이 정의함
예를 들어 List를 하나 정의하고 거기에 element를 집어넣으면 그 경우 List의 element를 추출하기 위해 반복문을 쓰는데
i < strList.size()를 쓰지 않고 i < 3001 과 같은 방식으로 하드 코딩을 해야만 예외 발생

향상된 for문 사용시 예외 발생할 일 없음

```java
class Person {
    int age;
    String name;

    void showInfo() {
        System.out.println("나이 : " + age);
        System.out.println("이름 : " + name);
        System.out.println();
    }
}

public class Exception01 {
    public static void main(String[] args) {
        Person person1 = new Person();
        person1.name = "김일";
        person1.age = 20;
        person1.showInfo();
        /*
            예외 처리를 적용한 코딩 -> try / catch / finally
         */
        int a = 10;
        int b = 0;
        try {
            int result = a / b;         // ArithmeticException 예외 발생 지검 -> 36번 라인이 아닌 catch로 넘어김
            System.out.println("결과 : " + result);
        } catch (ArithmeticException e) {
            System.out.println("0으로 나눌 수 없습니다." + e.getMessage());
        } finally {
            System.out.println("프로그램 정상 종료");
        }
        System.out.println();
        /*  
            예외 처리를 하는 이유
                : 프로그램이 정상 종료됨을 보증하기 위해

            일단 실행으로 오류 발생을 확인해야함?
         */

        // 배열 인덱스 예외 -> 복수 캐치문 사용
        int[] numbers = {1, 2, 3};
        try {
            System.out.println(numbers[5]);
        } catch (ArrayIndexOutOfBoundsException e) {
            System.out.println(e.getMessage());
        } catch (Exception e) {         // 예외 중에 가장 상위 예외 클래스에 해당
            throw new RuntimeException(e);      // 이 부분이 오류 메세지
        } finally {
            System.out.println("프로그램 정상 종료");
        }
    }
}
```
이상의 코드 라인에서 중요점은 catch 문이 복수로 나올 수 있다는 점
if문(leap year 관련) 작성시 조건의 순서 배치가 제일 중요하다고 강조

사실상 사용자 정의 예외 처리 방식 역시
try / catch / finally 와 throws / throw 가 추가됬을 뿐
method의 정의 / 생성자 정의 / 객체 생성 방식 이라는 여태까지 배워온 코드 작성 방법과 별 차이 없음


ex) Exception 예제
```java
public class InvalidAgeException extends Exception{
    // 사용자 정의 생성자 정의
    public InvalidAgeException(String message) {
        super(message);
    }
}

import java.util.InputMismatchException;
import java.util.Scanner;

public class AgeMain {
    // 예외 클래스는 별개로 정의했으나 메서드를 호출했을 때 예외를 처리해야하기에 여기에 추가로 메서드 정의(login()처럼)
    public static void checkAge(int age) throws InvalidAgeException {
        if(age < 0 || age > 200) {
            // 조건에 맞지 않는 경우 사용자 정의 예회 발생시킬것
            // 예외를 발생시킨다 -> 예외 객체를 생성
            throw new InvalidAgeException("나이는 0 ~ 200 사이의 정수만 가능합니다.");
        }
    }

    public static void main(String[] args) {
        // 사용할 클래스 import
        Scanner scanner = new Scanner(System.in);
        System.out.print("나이를 입력하세요 >>> ");
        // int age = scanner.nextInt();    // 전에는 여기에 바로 작성했으나
        // 이 부분에 음수값/200 초과 정수를 집어넣기 가능함 / double 자료형 가능
        // 예외가 발생 가능성 있는 부분을 try문 안에 넣는것이 중요
        try {
            int age = scanner.nextInt();
            checkAge(age);  // 예외를 던질(throw) 가능성이 있는 메서드 호출
            System.out.println("입력된 나이는 : " + age + "살입니다.");
        } catch (InvalidAgeException e) {
            System.out.println("나이 입력 오류 : " + e.getMessage());
        } catch (InputMismatchException e) {        // Scanner를 사용했는데 변수의 자료형과 일치하지 않으면 적용
            // 문자와 소수값이 동일한 예외 발생
            System.out.println("잘못된 입력입니다. 숫자를 입력하세요.");
        } finally {
            System.out.println("프로그램 정상 종료");
        }
    }
}
```
이상의 코드에서 정상적인 데이터 한 번 / 비정상적인 데이터를 한번 실행시켰을때 코드 출력 순서를 고려해야함
예외가 발생하지 않는다면 예외 관련 객체 생성할 필요도 없고 catch{} 문은 실행되지 않는다.
예와가 발생하면 예외 발생 시점 이후의 try{}문은 실행되지 않고 곧장 catch{} 문이 실행된다.
그리고 예외 발생 유무와 무관하게 finally{}문은 마지막에 실행




# Lambda Expression(람다식)
- Java 8에서 도입된 함수형 프로그래밍을 지원하기 위한 표현식

형식 :

```java
// (매개변수) -> { 실행문 }
public static void main(String[] args) {
    Runnable runnable = new Runnable() {
        @Override
        public void run() {
            System.out.println("Hello, Java");
        }
    };
    runnable.run();         // Hello, Java 출력
}
```
이상의 익명 클래스는 잠깐 나온적이 있는데 Interface Runnable을 활영헤 임식적으로 run() 추상 메서드를 재정의해 원하는 결과를 도출하는 형테

```java
// 람다식 적용 방식
public static void main(String[] args) {
    Runnable runnable = () -> System.out.println("Hello, Java");
    
    runnable.run();
}
```
람다식을 적용하면 이상의 한줄로 끝

## 람다식의 등장 배경
- 람다식이 나오기전에는 Java 에서 함수형 프로그래밍을 하기 위해 익명 클래스를 주로 사용(1번 예시)
- 하지만 이상의 방식은 코드가 길어지고 불필요한 반복이 많아 가독성이 떨어지는 문제 발생
  (call1() 유형의 코드를 5개 정의하면 runnable1, ... runnable5까지 객체명도 다 다르게 정의해야함)

```java
import java.util.Comparator;

public static void main(String[] args) {
    Comparator<Integer> comparator = new Comparator<Integer>() {
        @Override
        public int compare(Integer o1, Integer o2) {
            return o1.compareTo(o2);
        }
    };  // Comparator 인터페이스의 객체를 임의적으로 사용한 익명 클래스 예시
    
    Comparator<Integer> lambadaComparator = (o1, o2) -> o1.compareTo(o2);
}
```
## 람다식 장점
1. 코드 간결화 - 불필요한 코드 제거로(Integer 반복 없음) 가독성 향상
2. 표현력 향상 - 익명 클래스를 짧은 표현으로 대체
3. 지연 연산 - Stream API와 함꼐 사용 시 지연 연산을 통해 성능 최적화

## 람다식 단점
1. 디버깅 어려움 - 람다식 내부 오류의 디버깅 힘듬
2. 재사용성 낮음 - 익명 클래스에 비해 재사용 힘듬
3. 복잡한 로직 표현에 부적합 - 단순 로직의 경우 람다식, 아닌 경우 익명 클래스 사용

## 람다식 문법
람다식 구조는 크게 3가지로 구분
1. 매개변수 목록
2. 화살표(->) : 그래서 Js는 arrow expression 이라고 표현
3. 구현부/실행문(한국어판 inteliJ는 메서드 본문)

```java
public static void main(String[] args) {
    // 1. 매개변수와 실행문이 하나면(중괄호 생략 가능)
    (int x, int y) -> x + y // return 생략
    
    // 2. 매개변수가 하나일 때(소괄호 생략)
    str -> System.out.println(str);     // call2() 유형
    
    // 3. 실행문이 여러줄(중괄호 필수)
    (x, y) -> {
        // 지역 변수 선언
        int sum = x + y;
        return sum;
    }
}
```

## 함수형 인터페이스(Functional Interface)
- 람다식은 단일 메서드만 가지는 인터페이스(함수형 인터페이스)를 구현하는 형태로 사용
  @FunctionalInterface 애너테이션을 사용시 컴파일에서 단일 메서드인지 체크
- 그래서 사용자 정의 함수형 인터페이스를 작성시 클래스 레벨에 @FunctionalInterface를 명시

이유:
인터페이스에 있는 메서드는 전부 추상 메서드 -> 얘를 implement 받을시 추상 메서드를 전부다 강제로 구현해야함
그러나 call1() -> call4()까지의 유형을 하나의 객체에 강제구현하게 될 경우 call3()만 필요한데 나머지도 정의해야하는 문제가 생겨
각 유형당 하나의 인터페이스/추상메서드만 존재

```java
@FunctionalInterface    // 메서드 하나 초과면 오류 발생
interface MyFunction {
    void start();       // 인터페이스 정의하고 추상메서드가 하나 존재
}

public static void main(String[] args) {
    MyFunction myFunction = () -> System.out.println("정의한 함수를 실행합니다.");
    // 매개변수가 없는 경우 ()로 표시. 매개변수가 하나면 소괄호 생략
    
    myFunction.start();
}
```
## Java가 제공하는 주요 함수형 인터페이스
1. Runnable - void run(); - call()
2. Consumer - T get(); - call2()
3. Supplier - void accept(T t); - call3()
4. Function<T, R> - R apply(T t); - call4()
5. Predicate - boolean test(T t); - return 타입이 boolean 고정이라 call1~call4로 묶을순 없지만 비슷한 케이스는 call4()
                                    -> return true / false 중 하나이기에

### 함수형 인터페이스별 상세
1. Runnable
- 매개변수도 없고, 반환값도 없는 단순 실행을 위한 인터페이스
- 사용처 : 스레드 실행 시, 비동기 작업 실행시
2. Supplier
- 매개변수 없이 값을 반환하는 인터페이스, 단순히 값을 '공급'하는 역할
- 사용처 : 객체 생성, 지연 로딩
3. Consumer
- 값을 매개변수로 받아서 사용하고, 아무것도 반환하지 않는 인터페이스, 데이터를 소비하는 역할
4. Function<T, R>
- 하나의 매개변수를 바아서 연산을 수행하고 결과 리턴
  - T는 입력 타입, R은 리턴 타입을 명시
- 사용처 : 데이터 변환, 매핑 처리, 컬렉션 조작
5. Predicate
- 하나의 매개변수를 받아서 특정 조건을 검사한 뒤 true / false를 반환
- 사용처 : 필터링, 조건 검사, 유효성 검사
  - 특히 Predicate는 true / false 반환값을 가지고 조건문을 들릴 떄 많이 사용
6. 함수형 인터페이스 조합
- Java 8에서는 함수형 인터페이스끼리 조합 가능

```java
import java.util.function.Predicate;

public static void main(String[] args) {
    // 메서드 1
    Predicate<String> startsWithA = str -> str.startsWith("A");
    // 메서드 2
    Predicate<String> endsWithX = str -> str.endsWith("X");
    
    // and()로 두 조건 결합
    Predicate<String> startsWithAAndEndsWithX = startsWithA.and(endsWithX);

    System.out.println(startsWithAAndEndsWithX.test("Alex"));
}
```