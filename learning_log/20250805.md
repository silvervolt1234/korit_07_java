

## private -> 자기 클래스 내부에서만 접근 가능
1. 가장 제한적인 접근 지정자
2. 클래스 외부에서는 접근 불가
3. 데이터 보호 목적으로 사용
```java
public class Car {
    public String engine = "V6";
    
    public void showEngine() {
        System.out.println("엔진 정보 : " + engine);
    }
}
// 별개의 클래스
public class CarMain {
    public static void main(String[] args) {
        Car car1 = new Car();
        System.out.println(car1.engine);
        car1.showEngine();
    }
}
```
Car를 기준으로 field는 private / 일부 정보만 공개하는 method는 public 이기에
CarMain 에서 객체를 생성하는 것 가능(class level - public) / 
엔진 정보를 직접 조회하는 것(car1.engine)은 불가능. field는 private 이기에
하지만 method를 경유하여 조회는 가능(car1.showEngine()) - method는 public 이기에

## protected -> 같은 패키지 + 상속 관계에서 접근 가능
기본적으로 추후에 배울 default와 같지만 자식 클래스에서 상속받아 사용 가능
```java
package vehicle;

public class Car {
    public String brand = "기아";
}
    
// 같은 패키지의 다른 클래스
package vehicle;

import vehicle.Car;

public class MyCar extends Car {
    public void showBrand() {
        System.out.println(brand);
    }
}
```
추후 상속 개념 학습시 더 상세히 알지만 Car 클래스의 protected 필드의 brand를 동일한 패키지의 MyCar 클래스에서 '직접 조회'
(Getter와 같은 메서드 경유 x)

## (default) - 아무 접근 지정자도 없을 때(package-private)
1. 같은 패키지 안에서 접근 가능, 다른 패키지는 불가능
```java
class Car {
    String color = "red";
}
```
이상의 경우 class 레벨도 default / field 레벨도 default로 간주
그리고 여태까지 챕터 단위로 패키지를 만들었고 그 안에서 객체 생성을 했기에
별 문제 없이 패키지 내에서 클래스를 만들고(Car / CarMain을 만들고) 객체 생성 / 필드 조회 / 메서드 호출 가능

추후 접근 지정자를 분명히 명시해 직접 통제

## 실무적인 관점에서의 접근 지정자 선택
1. 필드는 원칙적으로 -> private
2. 메서드는 외부 공개 필요시 -> public
3. 상속 대상 메서드는 -> protected
4. 패키지 내부에서만 쓰이는 도우미 클래스 -> (default)

## 항상 그런것은 아니지만 염두해둘 부분
1. 필드는 보통 private로 지정하고 접근은 getter / setter 통하기(자동완성이 public인 이유)
2. 인터페이스나 라이브러리는 public을 최소화 할것. 이미 공개된 API는 복구 어려움
    - 다른 회사가 내가 만든 class를 사용 중 public이 된게 default로 바뀌면 이전 클래스를 사용 못해
      로직을 초기화 해야함

## 중첩학습 설정 

코드에서 중접학습 부분은
접근 지정자의 설정 수준에 따라 setter / getter가 필요/불필요 사례가 존재
예를 들어 게임을 하거나 sns를 할 경우 닉네임은 누구나 볼 수 있고 닉네임 필드는 public 으로 설정
그래서 getter를 통한 닉네임 호출을 필요 없어서 코드에서 getName() 메서드는 불핋요

어떤 클래스/필드/메서드를 어떤 접근지정자로 설정할지 고민 필요
현재로서는 필드는 private로 설정, getter / setter를 통한 우회 설정 및 조회를 목표




# 배열(Array)
## 배열의 필요성
여태까지는 10개의 정수형 데이터를 저장하려면 int 변수를 10번 선언해서 저장
배열은 같은 자료형의 데이터를 하나의 변수에 저장해서 관리하는 방식 -> Java에서
즉 하나느이 변수만 가지고 내부에 10개의 데이터 저장 가능

## 선언 방식
자료형[] 변수명
```java
형식:
자료형[] 변수명 = 데이터;
int[] arr01 = {1,2,3,4,5}; // 변수 선언 및 초기화에 해당

```
필드를 참조할 때 객체명.필드 형태로 참조
field를 직접 참조했다는 말은 length 필드 = public

그러나 배열 != 객체 -> 그러나 field로 length를 보유
빈 배열 생성
```java
int[] arr02 = new int [10]; // 10개짜리 방을 가진 비어있는 배열 생성
```
모든 것을 종합했을 때
배열 내부의 방의 개수 / 주소지의 한계값 -1을 항상 아는것은 아니기에
element 값을 출력하기 위한 반복문의 한계값을 설정할때 배열명.length 생활화

arr01 내부에 있는 1, 2, 3, 4, 5는 arr01[0], arr01[1],...arr01[4] 라는 변수명

변수의 개념을 다시 생각
```java
arr01[0] = 10;          // 재대입
     System.out.println(arr01[0]);       // 결과값: 10
```

main 에서 사용하는 불특정 String[] 배열을 argument로 하는 메서드를 호출했을 때
String[] 내부의 element 들을 한줄로 출력하는 method를 정의하는것이 목표

 다음 목표
 main 에서 사용하는 불특정 String[] 배열을 argument로 하는 메서드를 호출 시
 String[] 내부 elements 들의 값을 하나하나 다 입력받아 바꾸는 method 정의

입력 관련 메서드 정의
```java
public void writesElements(String[] strArray) {
// 여기서 스캐너를 import 하고 매개변수로 받은 배열에 값을 입력할 수
// 있도록 하는 method 정의
// 메서드 호출 한 후 내부에서 입력할 것이기에 Scanner를 여기에 import
    Scanner scanner = new Scanner(System.in);
    for (int i = 0; i < strArray.length; i++) {
        System.out.print((i+1) + "번째 element를 채우시오 >>> ");
        strArray[i] = scanner.nextLine();
       }
    }
```
```java
 public void writesElements(double[] strArray) {
     // 여기서 스캐너를 import 하고 매개변수로 받은 배열에 값을 입력할 수
     // 있도록 하는 method 정의
     // 메서드 호출 한 후 내부에서 입력할 것이기에 Scanner를 여기에 import
     Scanner scanner = new Scanner(System.in);
     for (int i = 0; i < strArray.length; i++) {
         System.out.print((i+1) + "번째 element를 채우시오 >>> ");
         strArray[i] = scanner.nextDouble();
     }
 }
```