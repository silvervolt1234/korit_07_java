## 메서드 보충
method - 순차적으로 실행되는 여러 코드들을 하나의 이름으로 묶은 것
call1() ~ call4()로 매개변수/return 윰 구분

 형식:
     (접근지정자) 리런타입 메서드명(매개변수1, 매개변수2) {
         메서드 내부에서 순차적 실행 코드들 -> 비지니스 로직
     }

 ex)
 정의 예시:
     public void writeSchedule(String date, String content) {
         System.out.println(date + "일의 스케쥴은 다음과 같습니다.");
         System.out.println(content);
     }
 호출 예시:
     객체명.writeSchedule("20250804", "메서드/오버로딩/클래스 복습");


# Getter / Setter
## Getter / Setter의 필요성
1. 문제상황
   - 클래스를 하나 만든다고 가정
   - ex) Person 클래스를 생성하며 이름, 나이 등의 정보 저장을 위해 필드를 선언
   ```java
    public class Person{
        String name;
        int age;
    }
   
    public class PersonMain {
        public static void main(String[] args){
          // Person 객체 생성
          Person person1 = new Person();    // 기본 생성자는 default
          person1.name = "김일";             // 객체에 값을 대입하는 법
          // 객체명.속석명 = 데이터;
          person1.age = -10;
   
          System.out.println(person1.name);  // 결과값: 김일
          System.out.println(person1.age);   // 결과값: -10
        }
    }
   ```
   - 이상의 코드를 확인 했을 때, 나이에 비정상적인 값이 대입. 이처럼 외부(다른 클래스)에서 직접 속성값을 대입할때,
   - 이상한 값이 들어가도 통제할수 없다는 문제 발생
   - -> 이를 해결하기 위한 getter / setter 개념

## Getter / Setter 란?
1. Setter
   - 데이터를 설정하는 역할의 메서드. 클래스 외부에서 필드를 직접 수정하지 않게 막고 특정 메서드를 경유해
   - 값을 전달받아 초기화 및 수정을 실행
2. Getter 
   - 데이터를 조회하는 역할의 메서드. 클래스 외부에서 필드를 직접 읽지 못하게 막고 특정 메서드를 경유해
   - 안전하게 값을 반환(return)하는 장치
3. 장점
   1. 데이터 보호   
      - 변수가 private 접근 제어자를 사용해 외부에서 직접 접근하지 못하게 데이터 보호 가능
   2. 데이터의 유효성 검증
      - Setter 메서드에서 입력된 데이터의 적합성을 판단하고 잘못된 값을 거부
   3. 캡슐화(Encapsulation)
      - 데이터를 숨기고 필요한 경우만 제한적 접근하게 해 클래스 내부 구현을 외부로 노출하지 않음
   4. 유연성 증가
      - 요구사항이 추후 바뀌어 데이터를 설정/조회 방식이 변경되도
      - 클래스(Main x) 내부의 메서드만 수정해 유지보수 용이
## Setter / Getter의 구조
### Setter
```java
    접근지정자_void set속성명1(자료형 변수형) {
        this.속성명1 = 변수명;
    }
    
    public void setName(String name) {
        this.name = name;
        
    }
```
### Getter
```java
    접근지정자 자료형 get속성명1() {
        return 속성명1;
    }
    
    public int getAge() {
        return age;
    }
```
### Setter를 기준으로 유효성 검증 예시
```java
    public class Person {
        // 필드 선언
        int age;
        public void setAge(int birth) {
            if (birth < 0 || birth > 200) {
                System.out.println("불가능한 나이 입력입니다.");
                return;        // method 에서 return;은 method 즉시 종료 키워드
                               // 이 이하는 아예 실행 불가
            } else {
                System.out.println("변경 전 나이 : " + age); // birth 대입 전
                this.age = birth;
                System.out.println("변경 후 나이 : " +age); // 대입 이후여서 동일 코드라도 다른 결과값
            }
        }
    }   
```

# 접근 지정자(Access Modifier)
## 정의
- 클래스, 필드, 변수, 메서드의 접근 범위를 제어하는 키워드
- 사용 이유
  - 정보 은닉(캡슐화 : Encapsulation)을 실현하고, 코드의 보안성과 유지보수정을 위해
## 접근 지정자의 정류
1. public - 모든 클래스에서 접근 가능
   - setter / getter를 alt + ins를 통해서 생성하면 public 이라는 것을 확인 가능
     애초에 다른 클래스에서 사용하려고 만든 것이기에 기본적으로 public 접근 지정자로 생성
2. protected - 같은 패키지 내의 클래스 및 이 클래스를 상속받은 자식 클래스에서 접근 가능
3. default - 접근 지정자를 명시하지 않으면 default로 간주되며 같은 패키지 내의 클래스에서 접근 가능
4. private - 같은 클래스 내에서만 접근 가능
   - 그래서 앞으로 일반적으로는 private 접근 지정자를 사용