# Object 클래스
- 모든 클래스는 Object 클래스를 상속 받는다. 그래서 interface를 implement할 때나 다른 sub 클래스를 만들어서 extends 했을 때
  직접 만든 슈퍼 클래스 이외에 toString 등을 활용함
    1. toString() : 기본적으로 모든 클래스는 Object 클래스를 상속 받아서 클래스 이름과 해시코드(주소지)를 return
       - 이를 Override 해서 재정의해 클래스의 정보 출력
       - 필드를 정의하고 toString() 메서드를 override 해서 필요한 필드를 출력
         -> Main 단계에서 특정 객체의 특정 필드를 객체의 이름만으로 출력 가능
            (sout(객체명);으로 가능 / sout(객체명.showInfo가 아님))
       
    2. equals() : 두 객체가 논리적으로 같은지를 비교하는 메서드(주소지의 차이 X). 기본적으로 Object 클래스의 equals() 메서드는
                  두 객체의 참조 주소를 비교
       - 형식 : 객체명1.equals(객체명2) -> 객체명1과 객체명2의 참조 주소가 동일한지 확인
                -> 3문장 형식으로 해석
       
    3. hashCode() : 객체를 정수 값(해시값)으로 변환(16진수가 아니라). 해시값은 줄 해시 기반 컬렉션에서 사용
       - equals 메서드를 재정의할시 반드시 hashCode() 메서드도 재정의 필요
         동일한 객체(equals == true)는 동일한 해시코드를 가져야하기 때문인데 해시코드가 같다고 equals()가 true가 아닌 경우 존재

# Lombok
메뉴바 -> 설정 -> 좌측 plugins(플러그인) 선택 -> Lombok 검색 -> 설치후 disabled/비활성화 표시시 활성화 된 상태

chrome -> maven repositories로 들어가 lombok 검색 -> 최신버전 코드 사용
빌드 시스템이 gradle 이기 때문에(코틀린 x) groovy short로 복사
annotationProcessor 적용

```java
dependencies {
    implementation 'org.projectlombok:lombok:1.18.38'
    annotationProcessor('org.projectlombok:lombok:1.18.38')
    testImplementation platform('org.junit:junit-bom:5.10.0')
    testImplementation 'org.junit.jupiter:junit-jupiter'
}
```
과 같이 작성


~~~~
정보를 담는 객체가 Entity class
-> 데이터베이스와 연결되는 클래스만 지칭하기 때문에특별한 지위에 위치
1열       2열         3열        4열        -> 세로줄(열/Column)
+----------------------------------------+
| username | password | email     | name |    -> 컬럼명 / Header
------------------------------------------
|    1      | 1234    | a@test.com| 서문성|    -> 가로줄(행/Row)
+----------------------------------------+
~~~~

# Lombok 주요 annotation
1. @Getter / @Setter
   - class level에 작성할 경우 getter / setter 메서드를 자동 생성
   - field level에 작성할 경우 해당 필드에만 메서드 생성
   - 주의 : 객체마다 다른 값을 갖는 비정형(non-static) 필드에 대해서만 적용

```java
@Setter
@Getter
public class Person {
    private String name;
    private int age;
}
```

2. @ToString
   - toString() 메서드를 자동으로 생성. 그러나 문제는 재정의가 안되고 Lombok 라이브러리 default 형태만 나오기에
     결과적으로 원하는 부분만 보여주기 위해서는 override methods(alt + ins) 사용 권장

3. @EqualsAndHashCode
   - equals() / hashCode() 메서드를 자동 생성. 객체의 동일성 비교 로직을 구현시 사용
     - equals()를 재젖ㅇ의하면 hashCode()도 반드시 재정의해야하기에 애너테이션도 세트

4. @NoArgsConstructor / @RequiredArgsConstructor / @AllArgsConstructor
   - @NoArgsConstructor : argument가 없는 기본 생성자 생성
   - @RequiredArgsConstructor ; final 또는 NonNull 애너테이션이 붙은 필드만 요구하는 매개변수 생성자 생성
   - @AllArgsConstructor : 모든 필드를 argument로 요구하는 매개변수 생성자
```java
@NoArgsConstructor
@RequiredArgsConstructor
@AllArgsConstructor

public class Person {
    @NonNull
    private String name;
    private int age;
}

public class PersonMain {
    public static void main(String[] args) {
        Person person1 = new Person();   // 기본생성자
        Person person2 = new Person("김이");  // name을 요구하는 매개변수 생성자
        Person person3 = new Person("김삼", 20);          // AllArgsConstructor
    }
}
```

4. @Data
   - @Getter / @Setter / @ToString / @EqualsAndHashCode / @RequiredArgsConstructor가 전부 포함된 패키지 애너테이션

빈출 생성 방식:
```java
@Data
@NoArgsConstructor
@AllArgsConstructor
public class Person {
    private String name;
    private int age;
    private double score;
}
```

5. @Builder

# Static

## 정의
- 클래스 수준에서 변수를 정의하거나 메서드 선언 시 사용
- static 으로 선언된 변수나 메서드는 클래스의 인스턴스에 미포함(해당 클래스의 인스턴스가 전부 동일값)
- 클래스 자체에 소속
- 이는 인스턴스를 생성하지 않고 접근이 가능하다는 점에서 일반적인 필드, 메서드와 구분